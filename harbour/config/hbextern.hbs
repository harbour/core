/*
 * $Id$
 */

/*
 * Harbour Project source code:
 * extern generator functions (low-level)
 *
 * Copyright 2010 Viktor Szakats (harbour.01 syenar.hu)
 * www - http://harbour-project.org
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA (or visit
 * their web site at http://www.gnu.org/).
 *
 */

#pragma warninglevel=3
#pragma -km+
#pragma -ko+

#define _HB_FUNC_INCLUDE_ "HB_FUNC_INCLUDE"
#define _HB_FUNC_EXCLUDE_ "HB_FUNC_EXCLUDE"

#define _HB_SELF_PREFIX   "__HBEXTERN__"
#define _HB_SELF_SUFFIX   "__"

STATIC FUNCTION __hb_extern_get_list( cInputName )
   LOCAL aExtern := NIL

   LOCAL cStdOut, cStdErr
   LOCAL cTempFile
   LOCAL hRegex
   LOCAL aResult
   LOCAL tmp

   LOCAL cCommand
   LOCAL cRegex := "[[:space:]]_?HB_FUN_([A-Z0-9_]*)[[:space:]]"

   /* NOTE: non-gcc extractor configs don't support dynamic libs as input. */
   DO CASE
   CASE "|" + GetEnv( "HB_COMPILER" ) + "|" $ "|gcc|mingw|mingw64|djgpp|"
      cCommand := "nm -g" + iif( GetEnv( "HB_PLATFORM" ) == "darwin", "", " --defined-only -C" ) + " {I}"
   CASE "|" + GetEnv( "HB_COMPILER" ) + "|" $ "|msvc|msvc64|pocc|pocc64|"
      IF "|" + GetEnv( "HB_COMPILER" ) + "|" $ "|msvc|msvc64|"
         cCommand := "dumpbin -symbols {I}"
      ELSE
         cCommand := "podump -symbols {I}"
      ENDIF
      cRegex := "SECT[0-9A-Z][0-9A-Z ].*[Ee]xternal.*_?HB_FUN_([A-Z0-9_]*)[[:space:]]"
   CASE GetEnv( "HB_COMPILER" ) == "watcom"
      cCommand := "wlib {I}"
   CASE GetEnv( "HB_COMPILER" ) == "bcc"
      cCommand := "tlib {I}, {T}"
   ENDCASE

   IF ! Empty( cCommand ) .AND. ;
      ! Empty( cRegex )
      IF hb_FileExists( cInputName )
         cCommand := StrTran( cCommand, "{I}", cInputName )
         IF "{T}" $ cCommand
            FClose( hb_FTempCreateEx( @cTempFile,,, ".tmp" ) )
            cCommand := StrTran( cCommand, "{T}", cTempFile )
         ENDIF
         IF hb_processRun( cCommand, @cStdErr, @cStdOut ) == 0
            IF ! Empty( cTempFile )
               cStdOut := MemoRead( cTempFile )
            ENDIF
            IF ! Empty( hRegex := hb_regexComp( cRegex, .T., .T. ) )
               aResult := hb_regexAll( hRegex, StrTran( cStdOut, Chr( 13 ) ),,,,, .T. )
               aExtern := {}
               FOR EACH tmp IN aResult
                  AAdd( aExtern, tmp[ 2 ] )
               NEXT
               ASort( aExtern,,, {| tmp, tmp1 | tmp < tmp1 } )
            ENDIF
         ENDIF
         IF ! Empty( cTempFile )
            FErase( cTempFile )
         ENDIF
      ENDIF
   ENDIF

   RETURN aExtern

STATIC PROCEDURE __hb_extern_get_exception_list( cInputName, /* @ */ aInclude, /* @ */ aExclude )
   LOCAL cFile
   LOCAL hRegex
   LOCAL tmp

   aInclude := {}
   aExclude := {}

   IF ! Empty( cFile := MemoRead( cInputName ) )
      IF ! Empty( hRegex := hb_regexComp( "[[:space:]]" + _HB_FUNC_INCLUDE_ + "[[:space:]]([a-zA-z0-9_].[^ \t\n\r]*)", .T., .T. ) )
         FOR EACH tmp IN hb_regexAll( hRegex, StrTran( cFile, Chr( 13 ) ),,,,, .T. )
            AAdd( aInclude, Upper( tmp[ 2 ] ) )
         NEXT
      ENDIF
      IF ! Empty( hRegex := hb_regexComp( "[[:space:]]" + _HB_FUNC_EXCLUDE_ + "[[:space:]]([a-zA-z0-9_].[^ \t\n\r]*)", .T., .T. ) )
         FOR EACH tmp IN hb_regexAll( hRegex, StrTran( cFile, Chr( 13 ) ),,,,, .T. )
            AAdd( aExclude, Upper( tmp[ 2 ] ) )
         NEXT
      ENDIF
   ENDIF

   RETURN

STATIC FUNCTION __hb_extern_gen( aFuncList, cOutputName )
   LOCAL aExtern
   LOCAL cExtern
   LOCAL tmp

   LOCAL aInclude
   LOCAL aExclude

   LOCAL cSelfName := _HB_SELF_PREFIX + Upper( __FNameNameGet( cOutputName ) ) + _HB_SELF_SUFFIX

   LOCAL cLine := "/* -------------------------------------------------------------------- */" + hb_eol()
   LOCAL cHelp := "/*          Syntax: // HB_FUNC_INCLUDE <func>                           */" + hb_eol() +;
                  "/*                  // HB_FUNC_EXCLUDE <func>                           */" + hb_eol()

   __hb_extern_get_exception_list( cOutputName, @aInclude, @aExclude )

   cExtern := "/*" + hb_eol()
   cExtern += " * $" + "Id" + "$" + hb_eol()
   cExtern += " */" + hb_eol()
   IF Empty( aInclude ) .AND. ;
      Empty( aExclude )
      cExtern += hb_eol()
      cExtern += cLine
      cExtern += "/* NOTE: You can add manual override which functions to include or      */" + hb_eol()
      cExtern += "/*       exclude from automatically generated EXTERNAL/DYNAMIC list.    */" + hb_eol()
      cExtern += cHelp
      cExtern += cLine
   ELSE
      cExtern += hb_eol()
      cExtern += cLine
      cExtern += "/* NOTE: Following comments are control commands for the generator.     */" + hb_eol()
      cExtern += "/*       Do not edit them unless you know what you are doing.           */" + hb_eol()
      cExtern += cHelp
      cExtern += cLine
      IF ! Empty( aInclude )
         cExtern += hb_eol()
         FOR EACH tmp IN aInclude
            cExtern += "// " + _HB_FUNC_INCLUDE_ + " " + tmp + hb_eol()
         NEXT
      ENDIF
      IF ! Empty( aExclude )
         cExtern += hb_eol()
         FOR EACH tmp IN aExclude
            cExtern += "// " + _HB_FUNC_EXCLUDE_ + " " + tmp + hb_eol()
         NEXT
      ENDIF
   ENDIF
   cExtern += hb_eol()
   cExtern += cLine
   cExtern += "/* WARNING: Automatically generated code below. DO NOT EDIT!            */" + hb_eol()
   cExtern += "/*          Regenerate with HB_REBUILD_EXTERN=yes while using GCC       */" + hb_eol()
   cExtern += "/*          compiler family. [vszakats]                                 */" + hb_eol()
   cExtern += cLine
   cExtern += hb_eol()
   cExtern += "#ifndef " + "__HBEXTERN_CH__" + Upper( __FNameNameGet( cOutputName ) ) + "__" + hb_eol()
   cExtern += "#define " + "__HBEXTERN_CH__" + Upper( __FNameNameGet( cOutputName ) ) + "__" + hb_eol()
   cExtern += hb_eol()
   cExtern += "#if defined( __HBEXTREQ__ ) .OR. defined( " + cSelfName + "ANNOUNCE" + " )" + hb_eol()
   cExtern += "   ANNOUNCE " + cSelfName + hb_eol()
   cExtern += "#endif" + hb_eol()
   cExtern += hb_eol()
   cExtern += "#if defined( __HBEXTREQ__ ) .OR. defined( " + cSelfName + "REQUEST" + " )" + hb_eol()
   cExtern += "   #command DYNAMIC <fncs,...> => EXTERNAL <fncs>" + hb_eol()
   cExtern += "#endif" + hb_eol()
   cExtern += hb_eol()
   IF Empty( aInclude )
      aExtern := aFuncList
   ELSE
      aExtern := {}
      FOR EACH tmp IN aFuncList
         IF AScan( aInclude, {| flt | hb_WildMatch( flt, tmp ) } ) > 0
            AAdd( aExtern, tmp )
         ENDIF
      NEXT
   ENDIF
   FOR EACH tmp IN aExtern
      IF ! hb_WildMatch( "HB_GT_*_DEFAULT", tmp ) .AND. ;
         ! hb_WildMatch( _HB_SELF_PREFIX + "*" + _HB_SELF_SUFFIX, tmp ) .AND. ;
         AScan( aExclude, {| flt | hb_WildMatch( flt, tmp ) } ) == 0
         cExtern += "DYNAMIC " + tmp + hb_eol()
      ENDIF
   NEXT
   cExtern += hb_eol()
   cExtern += "#if defined( __HBEXTREQ__ ) .OR. defined( " + cSelfName + "REQUEST" + " )" + hb_eol()
   cExtern += "   #uncommand DYNAMIC <fncs,...> => EXTERNAL <fncs>" + hb_eol()
   cExtern += "#endif" + hb_eol()
   cExtern += hb_eol()
   cExtern += "#endif" + hb_eol()

   RETURN hb_MemoWrit( cOutputName, cExtern )

STATIC FUNCTION __FNameNameGet( cFileName )
   LOCAL cName

   hb_FNameSplit( cFileName,, @cName )

   RETURN cName
