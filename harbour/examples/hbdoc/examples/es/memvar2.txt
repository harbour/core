/*
 * $Id$
 */

/*
 * Las siguientes partes son derechos adquiridos de sus autores individuales.
 * www - http://www.harbour-project.org
 *
 * Copyright 2003 Alejandro de G rate <alex_degarate@hotmail.com>
 * Documentaci¢n en Espa¤ol de:
 *   FIELD, LOCAL, MEMVAR
 *
 * Vea COPYING por los t‚rminos de la licencia.
 *
 */

/*  $DOC$
 *  $COMMANDNAME$
 *      FIELD
 *  $CATEGORY$
 *      Comando
 *  $ONELINER$
 *      Declara una lista de nombres de campo de una base de datos
 *  $SYNTAX$
 *      FIELD <xField> [,<xFieldn...>  [in <cDatabase>]
 *  $ARGUMENTS$
 *      <xField>    Un nombre de campo válido
 *
 *      <xFieldn>   Nombres de campo adicionales
 *
 *      <cDatabase> Un nombre de alias válido
 *  $RETURNS$
 *      Nada
 *  $DESCRIPTION$
 *      Este comando declara los nombres de los campos <xField> y siguientes
 *      <xFieldn> con una identificador opcional de alias <cDatabase> para
 *      cada uno.
 *      Este comando le permite a Harbour resolver cualquier referencia a un
 *      campo especificado en la lista de campos, viéndolo como un campo
 *      cuando no es referenciado por un alias.
 *      Si un campo no está mencionado en la lista y no está explicitamente
 *      marcado con el identificador de alias, éste puede ser visto como una
 *      variable de memoria, lo cual puede causar errores de ejecución.
 *
 *      Este comando no tiene efecto sobre variables de memoria ó sobre
 *      referencias a campos metidos dentro de una macro-expresión.
 *  $EXAMPLES$
 *      FUNCTION MAIN
 *        FIELD iD
 *        FIELD Name
 *        USE TESTS NEW
 *        name := "Sales"
 *        Id := 5
 *        USE
 *      RETURN NIL
 *  $TESTS$
 *      Ver ../tests/testwarn.prg
 *  $STATUS$
 *      R
 *  $COMPLIANCE$
 *      Este comando trabaja exactamente como en CA-Cl*pper.
 *  $PLATFORMS$
 *      Todas
 *  $FILES$
 *      Ninguno
 *  $SEEALSO$
 *      MEMVAR,PRIVATE,PUBLIC,STATIC
 *  $END$
 */


/*  $DOC$
 *  $COMMANDNAME$
 *      LOCAL
 *  $CATEGORY$
 *      Comando
 *  $ONELINER$
 *      Crea e inicializa una variable de memoria ó un array LOCAL
 *  $SYNTAX$
 *      LOCAL <xVar> [:= <xInit> ]
 *      LOCAL <xVar1>[:= <xInit1>], ..., <xVarN>[:= <xInitN>]
 *  $ARGUMENTS$
 *      <xVar>    Nombre de variable de Memoria ó array.
 *
 *      <xInit>   Valor a ser asignado a la variable ó array
 *  $RETURNS$
 *      Nada
 *  $DESCRIPTION$
 *      Este comando Crea una variable de memoria ó un array LOCAL
 *      El nombre de cualquiera es especificado en <xVar>.
 *      Si más de una variable está siendo inicializada con la sentencia
 *      LOCAL, separe cada una de ellas con una coma.
 *      Si una variable ó un array le va a ser asignado un valor de inicio
 *      esa expresión puede ser especificada en <xInit>, usando el operador
 *      de asignación en línea <:=>
 *
 *      Nota:
 *      Si el modo de compilación "Fuertemente Tipeado" (Strong type) es
 *      usado, el compilador chequeará si el valor recibido coincide con el
 *      tipo especificado en <xType>.
 *
 *      Las Variables LOCALes son símbolos generados en tiempo de ejecución
 *      y son resueltos en tiempo de compilación (???).
 *      La visibilidad y tiempo de vida de una variable ó array LOCAL está
 *      limitada a la función ó procedimiento en la cual ésta es definida.
 *
 *      Ninguna macro-expansión es permitida de una sentencia de declaración
 *      LOCAL.
 *
 *      Ningún comando de Harbour distinto a FUNCTION, PROCEDURE, PUBLIC,
 *      PRIVATE, PARAMETERS, MEMVAR, STATIC y FIELD, pueden preceder a la
 *      sentencia LOCAL (esto esta mal)
 *
 *      Las referencias a un array LOCAL pueden no ser inicializadas (por
 *      ej. asignarle un valor) en la misma línea de comando junto con la
 *      sentencia LOCAL. Esto puede ser hecho luego en el programa.
 *
 *      Variables y arrays de tipo LOCAL no son afectadas por el comando
 *      RELEASE.
 *  $EXAMPLES$
 *      Function Main2()
 *      Local n , lVar
 *
 *      n := IIF( lVar, 'A', 3 )
 *      n := 2
 *      n := 'a'
 *      n := seconds() + 2
 *      n := int( seconds() + 2 )
 *      Return NIL
 *  $TESTS$
 *      Ver ../tests/testwarn.prg por más ejemplos
 *  $STATUS$
 *      R
 *  $COMPLIANCE$
 *      Este comando trabaja exactamente como en CA-Cl*pper.
 *  $PLATFORMS$
 *      Todas
 *  $FILES$
 *      Ninguno
 *  $SEEALSO$
 *      FIELD,PRIVATE,PUBLIC,STATIC,MEMVAR
 *  $END$
 */

/*  $DOC$
 *  $COMMANDNAME$
 *      MEMVAR
 *  $CATEGORY$
 *      Comando
 *  $ONELINER$
 *      Declara variables PRIVATE, PUBLIC y arrays.
 *  $SYNTAX$
 *      MEMVAR <xVar>
 *  $ARGUMENTS$
 *      <xVar> Nombre de variable de Memoria
 *  $RETURNS$
 *      Nada
 *  $DESCRIPTION$
 *      Este comando le dice al compilador como resolver alguna referencia
 *      a una variable de memoria designada dentro de esta lista ó si posee
 *      un alias explícito con el prefijo "M->" ó bien "MEMVAR->"
 *      Solamente aquellas variables de memoria que no contengan ese prefijo
 *      son afectadas por este comando. Aquellas variables de memoria dentro
 *      de expansiones macro, no son afectadas por este comando.
 *
 *      La declaración MEMVAR debe aparecer antes que cualquier comando
 *      ejecutable; esta es similar a las sentencias LOCAL, STATIC, FIELD,
 *      PARAMETERS, FUNCTION y PROCEDURE
 *  $EXAMPLES$
 *      MEMVAR y As Numeric
 *      Function Main2()
 *      LOCAL n , lVar
 *
 *      n := IIF( lVar, 'A', 3 )
 *      n := 2
 *      n := 'a'
 *      n := seconds() + 2
 *      n := int( seconds() + 2 )
 *      y := n
 *      ? y
 *      Return NIL
 *  $TESTS$
 *      Ver ../tests/testwarn.prg por más ejemplos
 *  $STATUS$
 *      R
 *  $COMPLIANCE$
 *      Este comando trabaja exactamente como en CA-Cl*pper.
 *  $PLATFORMS$
 *      Todas
 *  $FILES$
 *      Ninguno
 *  $SEEALSO$
 *      LOCAL,STATIC,FIELD,PRIVATE,PUBLIC
 *  $END$
 */
