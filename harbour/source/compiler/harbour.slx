/*
 * $Id$
 */

/*
 * Harbour Project source code:
 * Compiler SimpLex rules
 *
 * Copyright 2000 Ron Pinkas <ronpinkas@profit-master.com>
 * www - http://www.harbour-project.org
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2, or (at your option)
 * any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this software; see the file COPYING.  If not, write to
 * the Free Software Foundation, Inc., 59 Temple Place, Suite 330,
 * Boston, MA 02111-1307 USA (or visit the web site http://www.gnu.org/).
 *
 * As a special exception, the Harbour Project gives permission for
 * additional uses of the text contained in its release of Harbour.
 *
 * The exception is that, if you link the Harbour libraries with other
 * files to produce an executable, this does not by itself cause the
 * resulting executable to be covered by the GNU General Public License.
 * Your use of that executable is in no way restricted on account of
 * linking the Harbour library code into it.
 *
 * This exception does not however invalidate any other reasons why
 * the executable file might be covered by the GNU General Public License.
 *
 * This exception applies only to the code released by the Harbour
 * Project under the name Harbour.  If you copy code from other
 * Harbour Project or Free Software Foundation releases into a copy of
 * Harbour, as the General Public License permits, the exception does
 * not apply to the code that you add in this way.  To avoid misleading
 * anyone as to the status of such modified files, you must delete
 * this exception notice from them.
 *
 * If you write modifications of your own for Harbour, it is your choice
 * whether to permit this exception to apply to your modifications.
 * If you do not wish that, delete this exception notice.
 *
 */

#define NUMERALS_PER_LINE 3000

/*
#define SHOW_LEX_TOKENS
#define DEBUG_LEX
*/

#ifdef DEBUG_LEX
   #undef DEBUG_INFO
      #define DEBUG_INFO(x) x
#endif

#undef LEX_ABBREVIATE
   #define LEX_ABBREVIATE 4

#undef YY_BUF_SIZE
   #define YY_BUF_SIZE HB_PP_STR_SIZE

static int iCloseSquare = 0, iWantsEOL, iWantsEXP, iWantsID, iWantsVAR;

/* Commented 2001-08-29 - Not really needed!
static char *aTexts[ NUMERALS_PER_LINE ];
int iTexts = 0;
*/

static unsigned char iIdentifier = 0;
static char *sIdOnHold, *s_sLastBlock = NULL;

char *     hb_comp_SLX_LastBlock( BOOL bReset );
long       hb_comp_SLX_Hex2L( char* sHex );
static int hb_comp_SLX_ElementToken( char* szToken, unsigned int iTokenLen );
static int hb_comp_SLX_InterceptAction( int iRet, char *sToken );
static int hb_comp_SLX_CustomAction( int x, int aiHold[], int *ptr_iHold, BOOL *ptr_bIgnoreWords, int iLastToken, char *sToken, char *s_szBuffer );

/* -----------------------------------------------------  Language Definitions. ---------------------------------------------------- */

/* Delimiters. */
ACCEPT_TOKEN_AND_DROP_DELIMITER_IF_ONE_OF_THESE( " \t" );

#define HB_CHK_BLOCK    LEX_CUSTOM_ACTION - 1

ACCEPT_TOKEN_AND_RETURN_DELIMITERS {
				     LEX_DELIMITER( ',' ) AS_TOKEN( ',' ),
				     LEX_DELIMITER( '(' ) AS_TOKEN( '(' ),
				     LEX_DELIMITER( ')' ) AS_TOKEN( ')' ),
				     LEX_DELIMITER( '[' ) AS_TOKEN( '[' ),
				     LEX_DELIMITER( ']' ) AS_TOKEN( ']'   + DONT_REDUCE ),
				     LEX_DELIMITER( '}' ) AS_TOKEN( '}'   + DONT_REDUCE ),
				     LEX_DELIMITER( ':' ) AS_TOKEN( ':' ),
				     LEX_DELIMITER( '=' ) AS_TOKEN( '=' ),
				     LEX_DELIMITER( '#' ) AS_TOKEN( NE1 ),
				     LEX_DELIMITER( '@' ) AS_TOKEN( '@' ),
				     LEX_DELIMITER( '<' ) AS_TOKEN( '<'   + DONT_REDUCE ),
				     LEX_DELIMITER( '>' ) AS_TOKEN( '>'   + DONT_REDUCE ),
				     LEX_DELIMITER( '!' ) AS_TOKEN( NOT   + DONT_REDUCE ),
				     LEX_DELIMITER( '{' ) AS_TOKEN( HB_CHK_BLOCK        ),
				     LEX_DELIMITER( '|' ) AS_TOKEN( '|'   + DONT_REDUCE ),
				     LEX_DELIMITER( '^' ) AS_TOKEN( POWER + DONT_REDUCE ),
				     LEX_DELIMITER( '%' ) AS_TOKEN( '%'   + DONT_REDUCE ),
				     LEX_DELIMITER( '*' ) AS_TOKEN( '*'   + DONT_REDUCE ),
				     LEX_DELIMITER( '/' ) AS_TOKEN( '/'   + DONT_REDUCE ),
				     LEX_DELIMITER( '+' ) AS_TOKEN( '+'   + DONT_REDUCE ),
				     LEX_DELIMITER( '-' ) AS_TOKEN( '-'   + DONT_REDUCE ),
				     LEX_DELIMITER( '$' ) AS_TOKEN( '$'   + DONT_REDUCE )
				   };

/* Custom Intermediate Token needed to be expanded. */
#define HB_LIT_ACT      LEX_CUSTOM_ACTION - 2
#define HB_NESTED_LIT   LEX_CUSTOM_ACTION - 3
#define HB_QOUT_ACT     LEX_CUSTOM_ACTION - 4
#define HB_RET_QOUT_LIT LEX_CUSTOM_ACTION - 5

/* Stream Pairs. */
DEFINE_STREAM_AS_ONE_OF_THESE {
                                START_WITH("\"")     END_WITH("\"" )  STOP_IF_ONE_OF_THESE("\n") TEST_LEFT(FALSE) AS_PAIR_TOKEN(HB_LIT_ACT),
                                START_WITH("'")      END_WITH("'")    STOP_IF_ONE_OF_THESE("\n") TEST_LEFT(FALSE) AS_PAIR_TOKEN(HB_LIT_ACT),
                                START_WITH("QOUT([") END_WITH("])\n") STOP_IF_ONE_OF_THESE("\n") TEST_LEFT(FALSE) AS_PAIR_TOKEN(HB_QOUT_ACT),
                                START_WITH("[")      END_WITH("]" )   STOP_IF_ONE_OF_THESE("\n") TEST_LEFT(TRUE ) AS_PAIR_TOKEN(HB_LIT_ACT),
                                START_WITH("[\"")    END_WITH("\"]" ) STOP_IF_ONE_OF_THESE("\n") TEST_LEFT(FALSE) AS_PAIR_TOKEN(HB_NESTED_LIT),
                                START_WITH("['")     END_WITH("\']" ) STOP_IF_ONE_OF_THESE("\n") TEST_LEFT(FALSE) AS_PAIR_TOKEN(HB_NESTED_LIT),
                                START_WITH("[[")     END_WITH("]]" )  STOP_IF_ONE_OF_THESE("\n") TEST_LEFT(FALSE) AS_PAIR_TOKEN(HB_NESTED_LIT)
                              };

START_NEW_LINE_IF_ONE_OF_THESE( "\n;" );


#define HB_SELF         LEX_CUSTOM_ACTION - 6

SELF_CONTAINED_WORDS_ARE {
                           LEX_WORD( ".AND." ) AS_TOKEN( AND     + DONT_REDUCE ),
                           LEX_WORD( ".NOT." ) AS_TOKEN( NOT     + DONT_REDUCE ),
                           LEX_WORD( ".OR."  ) AS_TOKEN( OR      + DONT_REDUCE ),
                           LEX_WORD( ":="    ) AS_TOKEN( INASSIGN   ),
                           LEX_WORD( "::"    ) AS_TOKEN( HB_SELF    ),
                           LEX_WORD( "=="    ) AS_TOKEN( EQ      + DONT_REDUCE ),
                           LEX_WORD( "<>"    ) AS_TOKEN( NE2     + DONT_REDUCE ),
                           LEX_WORD( "<="    ) AS_TOKEN( LE      + DONT_REDUCE ),
                           LEX_WORD( ">="    ) AS_TOKEN( GE      + DONT_REDUCE ),
                           LEX_WORD( "!="    ) AS_TOKEN( NE2     + DONT_REDUCE ),
                           LEX_WORD( "++"    ) AS_TOKEN( INC        ),
                           LEX_WORD( "+="    ) AS_TOKEN( PLUSEQ     ),
                           LEX_WORD( "--"    ) AS_TOKEN( DEC        ),
                           LEX_WORD( "-="    ) AS_TOKEN( MINUSEQ    ),
                           LEX_WORD( "->"    ) AS_TOKEN( ALIASOP    ),
                           LEX_WORD( "*="    ) AS_TOKEN( MULTEQ     ),
                           LEX_WORD( "**"    ) AS_TOKEN( POWER   + DONT_REDUCE ),
                           LEX_WORD( "/="    ) AS_TOKEN( DIVEQ      ),
                           LEX_WORD( "^="    ) AS_TOKEN( EXPEQ      ),
                           LEX_WORD( "%="    ) AS_TOKEN( MODEQ      )
                         };

/* Intermediate KeyWords when ambigious. */
#define DO_WHILE         701
#define DO_WHILE_WITH    702

/* KeyWords are grouped based on the next token they require. */
#define WANTS_VAR        703 /* Wants Variable (including Macros): DO, FOR, PRIVATE, PUBLIC */
#define WANTS_ID         704 /* Wants Identifier: ANNOUNCE, EXTERN, FIELD, FUNCTION, LOCAL, MEMVAR, PARAMETERS, PROCEDURE, STATIC */
#define WANTS_EOL        705 /* Wants EOL: ELSE, END, ENDCASE, ENDDO, ENDIF, EXIT, LOOP, NEXT, OTHERWISE, RECOVER */
#define WANTS_EXP        706 /* Wants Expression: BREAK, CASE, ELSEIF, IF, RETURN, WHILE */
#define REJECT_OP        707

#define HB_WANTS_VAR     LEX_CUSTOM_ACTION - 512
#define HB_WANTS_ID      LEX_CUSTOM_ACTION - 1024
#define HB_WANTS_EOL     LEX_CUSTOM_ACTION - 1536
#define HB_WANTS_EXP     LEX_CUSTOM_ACTION - 2048

/* When 2 identifiers are correct syntax like in class declaration, we have to temporarily store the 2nd identifier. */
#define HB_ID_ON_HOLD  LEX_CUSTOM_ACTION - 7

#define HB_MACRO_ERR   LEX_CUSTOM_ACTION - 8

#define HB_INIT_PROC   LEX_CUSTOM_ACTION - 9
#define HB_INIT_FUNC   LEX_CUSTOM_ACTION - 10
#define HB_EXIT_PROC   LEX_CUSTOM_ACTION - 11
#define HB_EXIT_FUNC   LEX_CUSTOM_ACTION - 12
#define HB_STATIC_PROC LEX_CUSTOM_ACTION - 13
#define HB_STATIC_FUNC LEX_CUSTOM_ACTION - 14

#define HB_DO_CASE_ID  LEX_CUSTOM_ACTION - 15

#define HB_DO_WHILE_ID   LEX_CUSTOM_ACTION - 16
#define HB_DO_WHILE_WITH LEX_CUSTOM_ACTION - 17

#define _WITH_ID_CR      LEX_CUSTOM_ACTION - 18
#define _WITH_ID_SEMI    LEX_CUSTOM_ACTION - 19

#define HB_IN            LEX_CUSTOM_ACTION - 20
#define HB_STEP          LEX_CUSTOM_ACTION - 21
#define HB_TO            LEX_CUSTOM_ACTION - 22
#define HB_WITH          LEX_CUSTOM_ACTION - 23

/* When reservered words are used as Identifier. */
#define HB_IDENTIFIER    LEX_CUSTOM_ACTION - 24

#define HB_INLINE        LEX_CUSTOM_ACTION - 25

#define USE_KEYWORDS

/* Key Words. */
LANGUAGE_KEY_WORDS_ARE {
                         LEX_WORD( "ANNOUNCE"            ) AS_TOKEN( HB_WANTS_ID  - ANNOUNCE         ),
                         LEX_WORD( "BEGIN{WS}SEQUENCE"   ) AS_TOKEN( BEGINSEQ         ),
                         LEX_WORD( "BREAK"               ) AS_TOKEN( HB_WANTS_EXP - BREAK            ),
                         LEX_WORD( "CASE"                ) AS_TOKEN( HB_WANTS_EXP - CASE             ),
                         LEX_WORD( "DECLARE"             ) AS_TOKEN( DECLARE          ),
                         LEX_WORD( "DO"                  ) AS_TOKEN( HB_WANTS_VAR - DO               ),
                         LEX_WORD( "DO{WS}CASE"          ) AS_TOKEN( DOCASE           ),
                         LEX_WORD( "DO{WS}WHILE"         ) AS_TOKEN( DO_WHILE         ),
                         LEX_WORD( "DO{WS}WHILE{WS}WITH" ) AS_TOKEN( DO_WHILE_WITH    ),
                         LEX_WORD( "ELSE"                ) AS_TOKEN( HB_WANTS_EOL - ELSE             ),
                         LEX_WORD( "ELSEIF"              ) AS_TOKEN( HB_WANTS_EXP - ELSEIF           ),
                         LEX_WORD( "END"                 ) AS_TOKEN( HB_WANTS_EOL - END              ),
                         LEX_WORD( "ENDCASE"             ) AS_TOKEN( HB_WANTS_EOL - ENDCASE          ),
                         LEX_WORD( "ENDDO"               ) AS_TOKEN( HB_WANTS_EOL - ENDDO            ),
                         LEX_WORD( "ENDIF"               ) AS_TOKEN( HB_WANTS_EOL - ENDIF            ),
                         LEX_WORD( "EXIT"                ) AS_TOKEN( HB_WANTS_EOL - EXIT             ),
                         LEX_WORD( "EXIT{WS}FUNCTION"    ) AS_TOKEN( HB_EXIT_FUNC     ),
                         LEX_WORD( "EXIT{WS}PROCEDURE"   ) AS_TOKEN( HB_EXIT_PROC     ),
                         LEX_WORD( "EXTERNAL"            ) AS_TOKEN( HB_WANTS_ID  - EXTERN           ),
                         LEX_WORD( "FIELD"               ) AS_TOKEN( HB_WANTS_ID  - FIELD            ),
                         LEX_WORD( "FOR"                 ) AS_TOKEN( HB_WANTS_VAR - FOR              ),
                         LEX_WORD( "FUNCTION"            ) AS_TOKEN( HB_WANTS_ID  - FUNCTION         ),
                         LEX_WORD( "IF"                  ) AS_TOKEN( HB_WANTS_EXP - IF               ),
                         LEX_WORD( "INIT{WS}FUNCTION"    ) AS_TOKEN( HB_INIT_FUNC     ),
                         LEX_WORD( "INIT{WS}PROCEDURE"   ) AS_TOKEN( HB_INIT_PROC     ),
                         LEX_WORD( "LOCAL"               ) AS_TOKEN( HB_WANTS_ID  - LOCAL            ),
                         LEX_WORD( "LOOP"                ) AS_TOKEN( HB_WANTS_EOL - LOOP             ),
                         LEX_WORD( "MEMVAR"              ) AS_TOKEN( HB_WANTS_ID  - MEMVAR           ),
                         LEX_WORD( "NEXT"                ) AS_TOKEN( HB_WANTS_EOL - NEXT             ),
                         LEX_WORD( "OTHERWISE"           ) AS_TOKEN( HB_WANTS_EOL - OTHERWISE        ),
                         LEX_WORD( "PARAMETERS"          ) AS_TOKEN( HB_WANTS_ID  - PARAMETERS       ),
                         LEX_WORD( "PRIVATE"             ) AS_TOKEN( HB_WANTS_VAR - PRIVATE          ),
                         LEX_WORD( "PROCEDURE"           ) AS_TOKEN( HB_WANTS_ID  - PROCEDURE        ),
                         LEX_WORD( "PUBLIC"              ) AS_TOKEN( HB_WANTS_VAR - PUBLIC           ),
                         LEX_WORD( "RECOVER"             ) AS_TOKEN( HB_WANTS_EOL - RECOVER          ),
                         LEX_WORD( "RECOVER{WS}USING"    ) AS_TOKEN( RECOVERUSING     ),
                         LEX_WORD( "RETURN"              ) AS_TOKEN( HB_WANTS_EXP - RETURN           ),
                         LEX_WORD( "STATIC"              ) AS_TOKEN( HB_WANTS_ID  - STATIC           ),
                         LEX_WORD( "STATIC{WS}FUNCTION"  ) AS_TOKEN( HB_STATIC_FUNC   ),
                         LEX_WORD( "STATIC{WS}PROCEDURE" ) AS_TOKEN( HB_STATIC_PROC   ),
                         LEX_WORD( "WHILE"               ) AS_TOKEN( HB_WANTS_EXP - WHILE            ),
                         LEX_WORD( "_HB_CLASS"           ) AS_TOKEN( DECLARE_CLASS    ),
                         LEX_WORD( "_HB_MEMBER"          ) AS_TOKEN( DECLARE_MEMBER   ),
                         LEX_WORD( "_PROCREQ_"           ) AS_TOKEN( PROCREQ          )
                       };

/* Intermediate Words when ambigious. */
#define QSELF     801
#define _LINE_    802

/* Words. */
LANGUAGE_WORDS_ARE {
                     LEX_WORD( ".F."             		) AS_TOKEN( FALSEVALUE         + DONT_REDUCE ),
                     LEX_WORD( ".N."             		) AS_TOKEN( FALSEVALUE         + DONT_REDUCE ),
                     LEX_WORD( ".T."             		) AS_TOKEN( TRUEVALUE          + DONT_REDUCE ),
                     LEX_WORD( ".Y."             		) AS_TOKEN( TRUEVALUE          + DONT_REDUCE ),

                     LEX_WORD( "AS{WS}ANYTYPE"   		) AS_TOKEN( AS_VARIANT         + DONT_REDUCE ),
                     LEX_WORD( "AS{WS}ARRAY"     		) AS_TOKEN( AS_ARRAY           + DONT_REDUCE ),
                     LEX_WORD( "AS{WS}ARRAY{WS}OF{WS}ANYTYPE"   ) AS_TOKEN( AS_ARRAY           + DONT_REDUCE ),
                     LEX_WORD( "AS{WS}ARRAY{WS}OF{WS}ARRAY"     ) AS_TOKEN( AS_ARRAY_ARRAY     + DONT_REDUCE ),
                     LEX_WORD( "AS{WS}ARRAY{WS}OF{WS}CHARACTER" ) AS_TOKEN( AS_CHARACTER_ARRAY + DONT_REDUCE ),
                     LEX_WORD( "AS{WS}ARRAY{WS}OF{WS}CLASS"     ) AS_TOKEN( AS_CLASS_ARRAY     + DONT_REDUCE ),
                     LEX_WORD( "AS{WS}ARRAY{WS}OF{WS}CODEBLOCK" ) AS_TOKEN( AS_BLOCK_ARRAY     + DONT_REDUCE ),
                     LEX_WORD( "AS{WS}ARRAY{WS}OF{WS}DATE"      ) AS_TOKEN( AS_DATE_ARRAY      + DONT_REDUCE ),
                     LEX_WORD( "AS{WS}ARRAY{WS}OF{WS}LOGICAL"   ) AS_TOKEN( AS_LOGICAL_ARRAY   + DONT_REDUCE ),
                     LEX_WORD( "AS{WS}ARRAY{WS}OF{WS}NUMERIC"   ) AS_TOKEN( AS_NUMERIC_ARRAY   + DONT_REDUCE ),
                     LEX_WORD( "AS{WS}ARRAY{WS}OF{WS}OBJECT"    ) AS_TOKEN( AS_OBJECT_ARRAY    + DONT_REDUCE ),
                     LEX_WORD( "AS{WS}ARRAY{WS}OF{WS}STRING"    ) AS_TOKEN( AS_CHARACTER_ARRAY + DONT_REDUCE ),
                     LEX_WORD( "AS{WS}ARRAY{WS}OF{WS}USUAL"     ) AS_TOKEN( AS_CHARACTER_ARRAY + DONT_REDUCE ),
                     LEX_WORD( "AS{WS}CHARACTER" 		) AS_TOKEN( AS_CHARACTER       + DONT_REDUCE ),
                     LEX_WORD( "AS{WS}CLASS"     		) AS_TOKEN( AS_CLASS           + DONT_REDUCE ),
                     LEX_WORD( "AS{WS}CODEBLOCK" 		) AS_TOKEN( AS_BLOCK           + DONT_REDUCE ),
                     LEX_WORD( "AS{WS}DATE"      		) AS_TOKEN( AS_DATE            + DONT_REDUCE ),
                     LEX_WORD( "AS{WS}LOGICAL"   		) AS_TOKEN( AS_LOGICAL         + DONT_REDUCE ),
                     LEX_WORD( "AS{WS}NUMERIC"   		) AS_TOKEN( AS_NUMERIC         + DONT_REDUCE ),
                     LEX_WORD( "AS{WS}OBJECT"    		) AS_TOKEN( AS_OBJECT          + DONT_REDUCE ),
                     LEX_WORD( "AS{WS}STRING"    		) AS_TOKEN( AS_CHARACTER       + DONT_REDUCE ),
                     LEX_WORD( "AS{WS}USUAL"                    ) AS_TOKEN( AS_CHARACTER       + DONT_REDUCE ),

                     LEX_WORD( "FIELD"           		) AS_TOKEN( FIELD              ),
                     LEX_WORD( "HB_INLINE"                      ) AS_TOKEN( HB_INLINE          ),
                     LEX_WORD( "IF"              		) AS_TOKEN( IIF                ),
                     LEX_WORD( "IIF"             		) AS_TOKEN( IIF                ),
                     LEX_WORD( "IN"              		) AS_TOKEN( HB_IN              ),
                     LEX_WORD( "LINE"                           ) AS_TOKEN( _LINE_             ),
                     LEX_WORD( "NIL"             		) AS_TOKEN( NIL                + DONT_REDUCE ),
                     LEX_WORD( "OPTIONAL"        		) AS_TOKEN( OPTIONAL           ),
                     LEX_WORD( "QSELF"           		) AS_TOKEN( QSELF              ),
                  /* LEX_WORD( "SELF"            		) AS_TOKEN( SELF               ), */
                     LEX_WORD( "STEP"            		) AS_TOKEN( HB_STEP            ),
                     LEX_WORD( "TO"              		) AS_TOKEN( HB_TO              ),
                     LEX_WORD( "WITH"              		) AS_TOKEN( HB_WITH            ),
                     LEX_WORD( "_FIELD"          		) AS_TOKEN( FIELD              ),
                     LEX_WORD( "_GET_"          		) AS_TOKEN( GET                )
                   };

/* Intermediate Reductions when still ambigious or need further reductions. */
#define _ID_ARRAY         901
#define _ID_COMMA         902
#define _ID_CR            903
#define _ID_SEMI          904
#define _ID_ASSIGN        905
#define _WHL_ID_CR        906
#define _WHL_ID_SEMI      907
#define _QOUT_LIT         908

/* When 2 identifiers are correct syntax like in class declaration, we have to temporarily store the 2nd identifier. */
#define _ID_ON_HOLD       913

LANGUAGE_RULES_ARE {
		    /* Wants any Var. */
                    IF_SEQUENCE_IS( WANTS_VAR      , IDENTIFIER  , 0      , 0          ) PASS_THROUGH(),
                    IF_SEQUENCE_IS( WANTS_VAR      , MACROVAR    , 0      , 0          ) PASS_THROUGH(),
                    IF_SEQUENCE_IS( WANTS_VAR      , MACROTEXT   , 0      , 0          ) PASS_THROUGH(),
                    IF_SEQUENCE_IS( WANTS_VAR      , '&'         , 0      , 0          ) PASS_THROUGH(),
                    IF_SEQUENCE_IS( WANTS_VAR      , 0           , 0      , 0          ) REDUCE_TO( HB_IDENTIFIER     , 0             ),

		    /* Wants Identifier. */
                    IF_SEQUENCE_IS( WANTS_ID       , IDENTIFIER  , 0      , 0          ) PASS_THROUGH(),
                    IF_SEQUENCE_IS( WANTS_ID       , 0           , 0      , 0          ) REDUCE_TO( HB_IDENTIFIER     , 0             ),

		    /* Wants EOL */
                    IF_SEQUENCE_IS( WANTS_EOL      , '\n'        , 0      , 0          ) PASS_THROUGH(),
                    IF_SEQUENCE_IS( WANTS_EOL      , ';'         , 0      , 0          ) PASS_THROUGH(),
                    IF_SEQUENCE_IS( WANTS_EOL      , 0           , 0      , 0          ) REDUCE_TO( HB_IDENTIFIER     , 0             ),

		    /* Wants Expression ( DOESN'T WANT OPERATORS ) - At BOL, if followed by operator (other than logicals .t., .f., !) than Identifier else COMMAND. */
                    IF_SEQUENCE_IS( REJECT_OP      , INC         , '\n'   , 0          ) PASS_THROUGH(),
                    IF_SEQUENCE_IS( REJECT_OP      , INC         , ';'    , 0          ) PASS_THROUGH(),
                    IF_SEQUENCE_IS( REJECT_OP      , DEC         , '\n'   , 0          ) PASS_THROUGH(),
                    IF_SEQUENCE_IS( REJECT_OP      , DEC         , ';'    , 0          ) PASS_THROUGH(),
                    IF_SEQUENCE_IS( REJECT_OP      , INASSIGN    , 0      , 0          ) PASS_THROUGH(),
                    IF_SEQUENCE_IS( REJECT_OP      , ALIASOP     , 0      , 0          ) PASS_THROUGH(),
                    IF_SEQUENCE_IS( REJECT_OP      , PLUSEQ      , 0      , 0          ) PASS_THROUGH(),
                    IF_SEQUENCE_IS( REJECT_OP      , MINUSEQ     , 0      , 0          ) PASS_THROUGH(),
                    IF_SEQUENCE_IS( REJECT_OP      , MULTEQ      , 0      , 0          ) PASS_THROUGH(),
                    IF_SEQUENCE_IS( REJECT_OP      , DIVEQ       , 0      , 0          ) PASS_THROUGH(),
                    IF_SEQUENCE_IS( REJECT_OP      , EXPEQ       , 0      , 0          ) PASS_THROUGH(),
                    IF_SEQUENCE_IS( REJECT_OP      , MODEQ       , 0      , 0          ) PASS_THROUGH(),
                 /* IF_SEQUENCE_IS( REJECT_OP      , '('         , 0      , 0          ) PASS_THROUGH(),
                    IF_SEQUENCE_IS( REJECT_OP      , '['         , 0      , 0          ) PASS_THROUGH(), DONT uncomment!!!*/
                    IF_SEQUENCE_IS( REJECT_OP      , '='         , 0      , 0          ) PASS_THROUGH(),
                    IF_SEQUENCE_IS( REJECT_OP      , ':'         , 0      , 0          ) PASS_THROUGH(),
                    IF_SEQUENCE_IS( REJECT_OP      , 0           , 0      , 0          ) REDUCE_TO( WANTS_EXP + DONT_REDUCE , 0             ),

                    IF_SEQUENCE_IS( REJECT_OP      , OPTIONAL     , 0      , 0         ) REDUCE_TO( WANTS_EXP + DONT_REDUCE , HB_IDENTIFIER ),
                    IF_SEQUENCE_IS( REJECT_OP      , WANTS_ID     , 0      , 0         ) REDUCE_TO( WANTS_EXP + DONT_REDUCE , HB_IDENTIFIER ),
                    IF_SEQUENCE_IS( REJECT_OP      , WANTS_EXP    , 0      , 0         ) REDUCE_TO( WANTS_EXP + DONT_REDUCE , HB_IDENTIFIER ),
                    IF_SEQUENCE_IS( REJECT_OP      , WANTS_VAR    , 0      , 0         ) REDUCE_TO( WANTS_EXP + DONT_REDUCE , HB_IDENTIFIER ),


		    /* Complex */

                    IF_SEQUENCE_IS( DOCASE       , '\n'       , 0      , 0          ) PASS_THROUGH(),
                    IF_SEQUENCE_IS( DOCASE       , ';'        , 0      , 0          ) PASS_THROUGH(),
                    IF_SEQUENCE_IS( DOCASE       , 0          , 0      , 0          ) REDUCE_TO( HB_DO_CASE_ID     , 0             ),

                    IF_SEQUENCE_IS( DO_WHILE_WITH, '\n'       , 0      , 0          ) REDUCE_TO( WHILE + DONT_REDUCE, _WITH_ID_CR  ),
                    IF_SEQUENCE_IS( DO_WHILE_WITH, ';'        , 0      , 0          ) REDUCE_TO( WHILE + DONT_REDUCE, _WITH_ID_SEMI),
                    IF_SEQUENCE_IS( DO_WHILE_WITH, 0          , 0      , 0          ) REDUCE_TO( HB_DO_WHILE_WITH  , 0             ),

                    IF_SEQUENCE_IS( DO_WHILE     , '\n'       , 0      , 0          ) REDUCE_TO( HB_DO_WHILE_ID    , '\n' + DONT_REDUCE        ),
                    IF_SEQUENCE_IS( DO_WHILE     , ';'        , 0      , 0          ) REDUCE_TO( HB_DO_WHILE_ID    , ';' + DONT_REDUCE         ),
                    IF_SEQUENCE_IS( DO_WHILE     , 0          , 0      , 0          ) REDUCE_TO( WHILE + DONT_REDUCE, 0             ),


		    /* DECLARE as PRIVATE. */
                    IF_SEQUENCE_IS( DECLARE     , IDENTIFIER  , '['    , 0          ) REDUCE_TO( PRIVATE    + DONT_REDUCE , _ID_ARRAY     ),
                    IF_SEQUENCE_IS( DECLARE     , IDENTIFIER  , ','    , 0          ) REDUCE_TO( PRIVATE    + DONT_REDUCE , _ID_COMMA     ),
                    IF_SEQUENCE_IS( DECLARE     , IDENTIFIER  , '\n'   , 0          ) REDUCE_TO( PRIVATE    + DONT_REDUCE , _ID_CR        ),
                    IF_SEQUENCE_IS( DECLARE     , IDENTIFIER  , ';'    , 0          ) REDUCE_TO( PRIVATE    + DONT_REDUCE , _ID_SEMI      ),
                    IF_SEQUENCE_IS( DECLARE     , IDENTIFIER  ,INASSIGN, 0          ) REDUCE_TO( PRIVATE    + DONT_REDUCE , _ID_ASSIGN    ),
                    IF_SEQUENCE_IS( DECLARE     , MACROVAR    , 0      , 0          ) REDUCE_TO( PRIVATE    + DONT_REDUCE , MACROVAR      ),
                    IF_SEQUENCE_IS( DECLARE     , MACROTEXT   , 0      , 0          ) REDUCE_TO( PRIVATE    + DONT_REDUCE , MACROTEXT     ),

		    /* Any other DECLARE IDENTIFIER, must be Strong Type DECLARE. */
                    IF_SEQUENCE_IS( DECLARE     , IDENTIFIER  , 0      , 0          ) PASS_THROUGH(),

                    IF_SEQUENCE_IS( _ID_ON_HOLD , 0           , 0      , 0          ) REDUCE_TO( HB_ID_ON_HOLD      , 0                   ),

		    /* Any other DECLARE must be Identifier. */
                    IF_SEQUENCE_IS( DECLARE     , 0           , 0      , 0          ) REDUCE_TO( HB_IDENTIFIER      , 0                   ),

		    /* Expnasions from DECLARE ...*/
                    IF_SEQUENCE_IS( _ID_ARRAY   , 0           , 0      , 0          ) REDUCE_TO( IDENTIFIER + DONT_REDUCE , '[' + DONT_REDUCE      ),
                    IF_SEQUENCE_IS( _ID_COMMA   , 0           , 0      , 0          ) REDUCE_TO( IDENTIFIER + DONT_REDUCE , ',' + DONT_REDUCE      ),
                    IF_SEQUENCE_IS( _ID_CR      , 0           , 0      , 0          ) REDUCE_TO( IDENTIFIER + DONT_REDUCE , '\n' + DONT_REDUCE     ),
                    IF_SEQUENCE_IS( _ID_SEMI    , 0           , 0      , 0          ) REDUCE_TO( IDENTIFIER + DONT_REDUCE , ';' + DONT_REDUCE      ),
                    IF_SEQUENCE_IS( _ID_ASSIGN  , 0           , 0      , 0          ) REDUCE_TO( IDENTIFIER + DONT_REDUCE , INASSIGN + DONT_REDUCE ),


		    /* This FIELD is NOT at BOL wants only ->. */
                    IF_SEQUENCE_IS( FIELD       , ALIASOP     , 0      , 0          ) PASS_THROUGH(),
                    IF_SEQUENCE_IS( FIELD       , 0           , 0      , 0          ) REDUCE_TO( HB_IDENTIFIER     , 0             ),


                 /* IF_SEQUENCE_IS( SELF        , ':'         , 0      , 0          ) PASS_THROUGH(),
                    IF_SEQUENCE_IS( SELF        , 0           , 0      , 0          ) REDUCE_TO( HB_IDENTIFIER     , 0             ), */

                    IF_SEQUENCE_IS( QSELF       , '('         , ')'    , 0          ) REDUCE_TO( SELF + DONT_REDUCE, 0             ),
                    IF_SEQUENCE_IS( QSELF       , 0           , 0      , 0          ) REDUCE_TO( HB_IDENTIFIER     , 0             ),

                    IF_SEQUENCE_IS( IIF         , '('         , 0      , 0          ) PASS_THROUGH(),
                    IF_SEQUENCE_IS( IIF         , 0           , 0      , 0          ) REDUCE_TO( HB_IDENTIFIER      , 0            ),

                    IF_SEQUENCE_IS( OPTIONAL    , IDENTIFIER  , 0      , 0          ) PASS_THROUGH(),
                    IF_SEQUENCE_IS( OPTIONAL    , '@'         , 0      , 0          ) PASS_THROUGH(),
                    IF_SEQUENCE_IS( OPTIONAL    , 0           , 0      , 0          ) REDUCE_TO( HB_IDENTIFIER     , 0             ),

                    IF_SEQUENCE_IS( PROCREQ     , '('         , 0      , 0          ) REDUCE_TO( PROCREQ + DONT_REDUCE, 0          ),
                    IF_SEQUENCE_IS( PROCREQ     , 0           , 0      , 0          ) REDUCE_TO( HB_IDENTIFIER     , 0             ),

                    IF_SEQUENCE_IS( GET         , '('         , 0      , 0          ) REDUCE_TO( GET + DONT_REDUCE , 0             ),
                    IF_SEQUENCE_IS( GET         , 0           , 0      , 0          ) REDUCE_TO( HB_IDENTIFIER     , 0             ),

                    IF_SEQUENCE_IS( NE1         , _LINE_      , 0      , 0          ) REDUCE_TO( LINE + DONT_REDUCE, 0             ),
                    IF_SEQUENCE_IS( _LINE_      , 0           , 0      , 0          ) REDUCE_TO( HB_IDENTIFIER     , 0             ),

                    IF_SEQUENCE_IS( '&'         , '\''        , 0      , 0          ) REDUCE_TO( HB_MACRO_ERR      , 0             ),
                    IF_SEQUENCE_IS( '&'         , '"'         , 0      , 0          ) REDUCE_TO( HB_MACRO_ERR      , 0             ),
                    IF_SEQUENCE_IS( '&'         , '['         , 0      , 0          ) REDUCE_TO( HB_MACRO_ERR      , 0             ),

                    IF_SEQUENCE_IS( _QOUT_LIT   , 0           , 0      , 0          ) REDUCE_TO( HB_RET_QOUT_LIT   , 0             )
                   };

/* -------------------------------------------------  End of Language Definitions. ------------------------------------------------ */

/* SimpLex Macros. */

#undef LEX_CASE
   #define LEX_CASE(x) ( (  ( iRet = (x) ) > 96 && iRet < 123 ) ? iRet - 32 : iRet )

/* Commented 2001-08-29 - Not really needed!
#undef NEW_LINE_ACTION
   #define NEW_LINE_ACTION() \
		while( iTexts ) \
                { \
                   DEBUG_INFO( printf( "Releasing short term Text: %i = %s At: %i\n", iTexts, aTexts[iTexts - 1], aTexts[iTexts - 1] ) ); \
                   iTexts--; \
                   hb_xfree( aTexts[iTexts] ); \
                }
*/

#undef INTERCEPT_ACTION
   #define INTERCEPT_ACTION(x) x = hb_comp_SLX_InterceptAction( x, (char*) sToken )

#undef ELEMENT_TOKEN
  #define ELEMENT_TOKEN(x,y) hb_comp_SLX_ElementToken(x,y)

#undef YY_INPUT      /* to implement our own YY_INPUT function to manage PRGs without \n at the end */
   extern FILE * yyin;  /* currently yacc parsed file */
   int yy_lex_input( char *, int );
   #define YY_INPUT( buf, result, max_size ) result = yy_lex_input( buf, max_size );

#undef CUSTOM_ACTION
   #define CUSTOM_ACTION(x) x = hb_comp_SLX_CustomAction( x, aiHold, &iHold, &bIgnoreWords, iLastToken, (char*) sToken, s_szBuffer )

#undef STREAM_EXCEPTION
   #define STREAM_EXCEPTION( sPair, cChar ) \
	   if( sTerm[1] == ']' && iCloseSquare ) \
	   { \
              szBuffer -= ( ( strlen( sPair ) - iCloseSquare ) + 1 ); \
	      sPair[ iCloseSquare - 1 ] = '\0'; \
              aiHold[ iHold++ ] = HB_LIT_ACT; \
	   } \
	   else \
	   { \
	      hb_compGenError( hb_comp_szErrors, 'E', HB_COMP_ERR_STRING_TERMINATOR, sPair, NULL ); \
              aiHold[ iHold++ ] = '\n'; \
              yylval.string = hb_compIdentifierNew( sPair, TRUE ); \
              aiHold[ iHold++ ] = LITERAL + DONT_REDUCE ; \
	   } \

#undef STREAM_APPEND
   #define STREAM_APPEND(x) \
      if( iPairLen == 0 && sStart[1] ) { sPair[ iPairLen++ ] = sStart[1]; } \
      if( x == ']' && iCloseSquare == 0 ) { iCloseSquare = iPairLen + 1; } sPair[ iPairLen++ ] = x;

#undef STREAM_OPEN
   #define STREAM_OPEN( sStarter ) \
      { \
         iCloseSquare = 0; \
	 \
         if( sStarter[0] == 'Q' ) \
           bTmp = FALSE /* TODO: hb_pp_bInsideTextBlock */; \
         else \
           bTmp = TRUE; \
      } \
      if( bTmp )

#undef IF_BELONG_LEFT
   #define IF_BELONG_LEFT(chr) if( iLastToken == IDENTIFIER || iLastToken == ']' || iLastToken == MACROVAR || iLastToken == MACROTEXT || iLastToken == ')' || iLastToken == '}' || iLastToken == WANTS_EOL || iLastToken == WANTS_ID || iLastToken == WANTS_VAR || iLastToken == DECLARE || iLastToken == FIELD || /*iLastToken == SELF ||*/ iLastToken == QSELF || iLastToken == IIF || iLastToken == PROCREQ )

/* Support Functions. */
int hb_comp_SLX_InterceptAction( int iRet, char *sToken )
{
   extern char *yytext;
   extern int  yyleng;

   if( iRet < 256 )
   {
      yytext[0] = iRet;
      yytext[1] = '\0';
      yyleng = 1;
   }
   else if( iRet < 512 )
   {
      if( iRet == IDENTIFIER )
      {
         if( iIdentifier > 0 )
         {
            iIdentifier--;
         }
      }
      else if( yylval.string == NULL )
      {
         yytext = sToken;
         yyleng = strlen( yytext );
      }
   }
   else
   {
      yytext = sToken;
      yyleng = strlen( yytext );

      if( iRet == WANTS_EXP )
         { iRet = iWantsEXP; }
      else if( iRet == WANTS_EOL )
         { iRet = iWantsEOL; }
      else if( iRet == WANTS_ID )
         { iRet = iWantsID; }
      else if( iRet == WANTS_VAR )
         { iRet = iWantsVAR; }
      else if( iRet == REJECT_OP )
         { yylval.string = hb_compIdentifierNew( (char*) sToken, TRUE ); iRet = IDENTIFIER; }
      else
         { printf( "Error SLX0001 Missing handler for '%i' line: %i\n", iRet, hb_comp_iLine - 1 ); hb_comp_iErrorCount++; }
   }

   #ifdef SHOW_LEX_TOKENS
      if( iRet == IDENTIFIER )
         printf( "   IDENTIFIER = \"%s\"\n", yylval.string  );
      else if( iRet == LITERAL )
         printf( "   LITERAL = \"%s\"\n", yylval.string  );
      else if( iRet == MACROVAR )
         printf( "   MACROVAR = \"%s\"\n", yylval.string  );
      else if( iRet == MACROTEXT )
         printf( "   MACROTEXT = \"%s\"\n", yylval.string  );
      else if( iRet == NUM_INTEGER )
         printf( "   INTEGER = %i\n", yylval.valInteger.iNumber  );
      else if( iRet == NUM_LONG )
         printf( "   INTEGER = %il\n", yylval.valLong.lNumber  );
      else if( iRet == NUM_DOUBLE )
   	 printf( "   DOUBLE = %f\n", yylval.valDouble.dNumber  );
     else if( iRet < 256 )
     {
   	if( iRet == '\n' || iRet == ';' )
      	   printf( "***NEW LINE %i\n", hb_comp_iLine - 1  );
   	else if( iRet == -1 )
      	   printf( "!!!<EOF>\n" );
	else
      	   printf( "   DELIMITER = \"%c\"\n", iRet  );
     }
     else
   	printf( "   TOKEN = %i\n", iRet  );
   #endif

   return iRet;
}

static int hb_comp_SLX_ElementToken( char* szToken, unsigned int iTokenLen )
{
   extern char *yytext;
   extern int yyleng;

   char* tmpPtr;
   int   iRet;

   yytext = szToken;
   yyleng = (int) iTokenLen;

   if( ( *yytext > 64 && *yytext < 91 ) || *yytext == '&' || *yytext == '_' )
   {
      /* Macro. */
      if( ( tmpPtr = strrchr( yytext, '&' ) ) != NULL ) /* Right Search. */
      {
         /* Is '&' the first char? - Since its was right search that would be the only '&'. */
         if( tmpPtr == yytext )
         {
            /* Maybe just the Macro Operator. */
            if( yyleng == 1 )
            {
               iRet = '&';
            }
            /* No '.' so Simple Macro. */
            else if( ( tmpPtr = strchr( yytext, '.' ) ) == NULL ) /* Left Search. */
            {
               /* Remove the '&'. */
               yytext++;
               yyleng--;

               yylval.string = hb_compIdentifierNew( yytext, TRUE );
               iRet = MACROVAR;
            }
            else if( tmpPtr == yytext + yyleng - 1 )
            {
               /* The only '.' is last char, so Simple Macro. */

               /* Remove the '&' and the '.' */
               yytext++;
               yyleng -= 2;
               yytext[yyleng] = '\0';

               yylval.string = hb_compIdentifierNew( yytext, TRUE );
               iRet = MACROVAR;
            }
            else
            {
               /*
               yytext = hb_compIdentifierNew( yytext, TRUE );
               */
               yylval.string = hb_strdup( yytext );
               iRet = MACROTEXT;
            }
         }
         else
         {
            /*
            yytext = hb_compIdentifierNew( yytext, TRUE );
            */
            yylval.string = hb_strdup( yytext );
            iRet = MACROTEXT;
         }
      }
      else
      {
   	 DEBUG_INFO( printf(  "Element \"%s\" is IDENTIFIER\n", yytext ) );

         if( yyleng > HB_SYMBOL_NAME_LEN )
         {
            yytext[ HB_SYMBOL_NAME_LEN ] = '\0';
            yyleng = HB_SYMBOL_NAME_LEN;
         }

         if( iIdentifier )
         {
            DEBUG_INFO( printf( "*** iDentifier = %i - Holding %s\n", iIdentifier, yytext ) );
            sIdOnHold = hb_compIdentifierNew( yytext, TRUE );
            iRet = _ID_ON_HOLD;
         }
         else
         {
            iIdentifier++;
            DEBUG_INFO( printf( "Primary Identifier %s Increased to: %i\n", yytext, iIdentifier ) );
            yylval.string = hb_compIdentifierNew( yytext, TRUE );
   	    iRet = IDENTIFIER;
         }
      }
   }
   else
   {
      /* ConverNumber */

      yylval.string = (char*) hb_xgrab( TOKEN_SIZE );
      yylval.string[0] = 0;

      /* Commented 2001-08-29 - Not really needed!
      if( iTexts < NUMERALS_PER_LINE )
      {
         aTexts[iTexts++] = yylval.string;
      }
      else
      {
	 printf( "Error SLX0002 Too many numerals in line: %i\n", hb_comp_iLine - 1 );
	 hb_comp_iErrorCount++;
	 iTexts = 0;
      }
      */

      /* Hex Number */
      if( yytext[0] == '0' && yytext[1] == 'X' )
      {
         long lNumber = hb_comp_SLX_Hex2L( yytext + 2 );

         if( ( double ) SHRT_MIN <= lNumber && lNumber <= ( double ) SHRT_MAX )
         {
       	    yylval.valInteger.iNumber = lNumber;
       	    yylval.valInteger.szValue = yytext;
       	    iRet = NUM_INTEGER;
         }
         else if( ( double ) LONG_MIN <= lNumber && lNumber <= ( double ) LONG_MAX )
         {
       	    yylval.valLong.lNumber = lNumber;
       	    yylval.valLong.szValue = yytext;
       	    iRet = NUM_LONG;
         }
         else
         {
       	    /* NOTE: This will never happen */
       	    yylval.valDouble.dNumber = lNumber;
       	    yylval.valDouble.bWidth = HB_DEFAULT_WIDTH;
       	    yylval.valDouble.bDec = 0;
       	    yylval.valDouble.szValue = yytext;
       	    iRet = NUM_DOUBLE;
         }
      }
      else
      {
         yylval.valDouble.dNumber = atof( yytext );
         tmpPtr = strchr( yytext, '.' );

         if( tmpPtr )
         {
       	    yylval.valDouble.bDec = strlen( tmpPtr + 1 );
       	    yylval.valDouble.bWidth = yyleng - yylval.valDouble.bDec;
       	    if( yylval.valDouble.bDec )
	    {
               yylval.valDouble.bWidth--;
	    }
       	    yylval.valDouble.szValue = yytext;
       	    iRet = NUM_DOUBLE;
         }
         else
         {
       	    if( ( double )SHRT_MIN <= yylval.valDouble.dNumber && yylval.valDouble.dNumber <= ( double )SHRT_MAX )
       	    {
               yylval.valInteger.iNumber = ( int ) yylval.valDouble.dNumber;
               yylval.valInteger.szValue = yytext;
               iRet = NUM_INTEGER;
       	    }
       	    else if( ( double )LONG_MIN <= yylval.valDouble.dNumber && yylval.valDouble.dNumber <= ( double )LONG_MAX )
       	    {
               yylval.valLong.lNumber = ( long ) yylval.valDouble.dNumber;
               yylval.valLong.szValue = yytext;
               iRet = NUM_LONG;
       	    }
       	    else
       	    {
               yylval.valDouble.bWidth = yyleng + 1;
               yylval.valDouble.bDec = 0;
               yylval.valDouble.szValue = yytext;
               iRet = NUM_DOUBLE;
       	    }
         }
      }

      iRet += DONT_REDUCE;
   }

   DEBUG_INFO( printf(  "Element \"%s\" is %i\n", szToken, iRet ) );
   return iRet;
}

long hb_comp_SLX_Hex2L( char* sHex )
{
   int i, iExp = 0, iLen = strlen( sHex ) - 1;
   long lVal, lSum = 0;
   char cChar;

   while( iLen >= 0 )
   {
      cChar = sHex[ iLen-- ];

      if( cChar > 64 && cChar < 91 )
      {
         lVal = cChar - 55;
      }
      else
      {
         lVal = cChar - 48;
      }

      if( lVal )
      {
	 i = 0;
	 while( i++ < iExp )
	 {
	    lVal *= 16;
	 }

         lSum += lVal;
      }

      iExp++;
   }

   return lSum;
}

int hb_comp_SLX_CustomAction( int x, int aiHold[], int *ptr_iHold, BOOL *ptr_bIgnoreWords, int iLastToken, char *sToken, char *s_szBuffer )
{
   DEBUG_INFO( printf( "Custom Action for %i\n", x ) );

   if( x < HB_WANTS_EXP )
   {
      *ptr_bIgnoreWords = FALSE;
      iWantsEXP = (-x) + (HB_WANTS_EXP) ;
      return REJECT_OP;
   }
   else if( x < HB_WANTS_EOL )
   {
      iWantsEOL = (-x) + (HB_WANTS_EOL) ;
      return WANTS_EOL;
   }
   else if( x < HB_WANTS_ID )
   {
      iWantsID = (-x) + (HB_WANTS_ID) ;
      return WANTS_ID;
   }
   else if( x < HB_WANTS_VAR )
   {
      iWantsVAR = (-x) + (HB_WANTS_VAR) ;
      return WANTS_VAR;
   }

   switch ( x )
   {
      case HB_IDENTIFIER :
         yylval.string = hb_compIdentifierNew( (char*) sToken, TRUE );
         iIdentifier++;
         DEBUG_INFO( printf( "Primary Identifier %s Increased to: %i\n", (char*) sToken, iIdentifier ) );
         return IDENTIFIER + DONT_REDUCE;

      case HB_SELF :
         aiHold[ (*ptr_iHold)++ ] = ':' + DONT_REDUCE ;
         yylval.string = hb_compIdentifierNew( "SELF", TRUE );
	 iIdentifier++;
	 DEBUG_INFO( printf( "HB_SELF, Primary Identifier %s Increased to: %i\n", "SELF", iIdentifier ) );
         return IDENTIFIER;

      case HB_CHK_BLOCK :
	 if( s_sLastBlock == NULL )
	 {
	    char *pTmp = (char *) s_szBuffer;

	    /* Skip White Space. */
	    while( *pTmp && ( *pTmp == ' ' || *pTmp == '\t' ) )
	    {
               pTmp++;
	    }

	    if( *pTmp == '|' )
	    {
	       unsigned int iBrackets = 1;
	       char cTmp;
	       BOOL bMacro = FALSE;

               pTmp++;
	       while( *pTmp )
	       {
		  if( *pTmp == '}' )
		  {
		     iBrackets--;
		     if( iBrackets == 0 )
		     {
		        break;
		     }
		  }
		  else if( *pTmp == '{' )
		  {
		     iBrackets++;
		  }
		  else if( *pTmp == '&' )
		  {
		     bMacro = TRUE;
		  }

                  pTmp++;
	       }

	       if( bMacro )
	       {
	          pTmp++;
	          cTmp = *pTmp;
	          *pTmp = '\0';

	          s_sLastBlock = hb_compIdentifierNew( s_szBuffer - 1, TRUE );

	          *pTmp = cTmp;
	       }
	    }
	 }
	 return '{' + DONT_REDUCE;

      case HB_LIT_ACT :
         yylval.string = hb_compIdentifierNew( sPair, TRUE );
         return LITERAL + DONT_REDUCE ;

      case HB_INIT_PROC :
         aiHold[ (*ptr_iHold)++ ] = PROCEDURE + DONT_REDUCE;
         return INIT + DONT_REDUCE;

      case HB_INIT_FUNC :
         aiHold[ (*ptr_iHold)++ ] = FUNCTION + DONT_REDUCE;
         return INIT + DONT_REDUCE;

      case HB_EXIT_PROC :
         aiHold[ (*ptr_iHold)++ ] = PROCEDURE + DONT_REDUCE;
         return EXIT + DONT_REDUCE;

      case HB_EXIT_FUNC :
         aiHold[ (*ptr_iHold)++ ] = FUNCTION + DONT_REDUCE;
         return EXIT + DONT_REDUCE;

      case HB_STATIC_PROC :
         aiHold[ (*ptr_iHold)++ ] = PROCEDURE + DONT_REDUCE;
         return STATIC + DONT_REDUCE;

      case HB_STATIC_FUNC :
         aiHold[ (*ptr_iHold)++ ] = FUNCTION + DONT_REDUCE;
         return STATIC + DONT_REDUCE;

      case HB_IN :
         *ptr_bIgnoreWords = FALSE;
	 if( iLastToken == IDENTIFIER )
	    { return IN + DONT_REDUCE; }
	 else
	 {
            yylval.string = hb_compIdentifierNew( "IN", TRUE );
            iIdentifier++;
            DEBUG_INFO( printf( "HB_IN, Primary Identifier %s Increased to: %i\n", "IN", iIdentifier ) );
            return IDENTIFIER;
         }

      case HB_STEP :
         *ptr_bIgnoreWords = FALSE;
         if( iLastToken == NUM_INTEGER || iLastToken == NUM_LONG || iLastToken == NUM_DOUBLE || iLastToken == IDENTIFIER || iLastToken == MACROVAR || iLastToken == MACROTEXT || iLastToken == ')' || iLastToken == ']' )
	    { return STEP + DONT_REDUCE; }
	 else
         {
            yylval.string = hb_compIdentifierNew( "STEP", TRUE );
            iIdentifier++;
            DEBUG_INFO( printf( "HB_STEP, Primary Identifier %s Increased to: %i\n", "STEP", iIdentifier ) );
            return IDENTIFIER;
         }

      case HB_TO :
         *ptr_bIgnoreWords = FALSE;
         if( iLastToken == NUM_INTEGER || iLastToken == NUM_LONG || iLastToken == NUM_DOUBLE || iLastToken == IDENTIFIER || iLastToken == MACROVAR || iLastToken == MACROTEXT || iLastToken == ')' || iLastToken == ']' )
	    { return TO + DONT_REDUCE; }
	 else
            {
              yylval.string = hb_compIdentifierNew( "TO", TRUE );
              iIdentifier++;
              DEBUG_INFO( printf( "HB_TO, Primary Identifier %s Increased to: %i\n", "IN", iIdentifier ) );
              return IDENTIFIER;
            }

      case HB_WITH :
         *ptr_bIgnoreWords = FALSE;
	 if( iLastToken == IDENTIFIER || iLastToken == MACROVAR || iLastToken == MACROTEXT || iLastToken == ')' )
	    { return WITH + DONT_REDUCE; }
	 else
	 {
            yylval.string = hb_compIdentifierNew( "WITH", TRUE );
            iIdentifier++;
            DEBUG_INFO( printf( "HB_WITH, Primary Identifier %s Increased to: %i\n", "WITH", iIdentifier ) );
            return IDENTIFIER;
	  }

      case _WITH_ID_CR :
         aiHold[ (*ptr_iHold)++ ] = '\n' + DONT_REDUCE;
         yylval.string = hb_compIdentifierNew( "WITH", TRUE );
	 iIdentifier++;
	 DEBUG_INFO( printf( "_WITH_ID_CR, Primary Identifier %s Increased to: %i\n", "WITH", iIdentifier ) );
         return IDENTIFIER + DONT_REDUCE;

      case _WITH_ID_SEMI :
         aiHold[ (*ptr_iHold)++ ] = ';' + DONT_REDUCE;
         yylval.string = hb_compIdentifierNew( "WITH", TRUE );
	 iIdentifier++;
	 DEBUG_INFO( printf( "_WITH_ID_SEMI, Primary Identifier %s Increased to: %i\n", "WITH", iIdentifier ) );
         return IDENTIFIER + DONT_REDUCE;

      case HB_NESTED_LIT :
	 {
	    int iPairLen = strlen( sPair );

	    sPair[ iPairLen ] = sTerm[0];
	    sPair[ iPairLen + 1 ] = '\0';
            yylval.string = hb_compIdentifierNew( sPair, TRUE );
            return LITERAL + DONT_REDUCE ;
	 }

      case HB_QOUT_ACT :
	 iIdentifier++;
	 DEBUG_INFO( printf( "HB_QOUT_ACT, Primary Identifier %s Increased to: %i\n", "QOUT", iIdentifier ) );
         yylval.string = hb_compIdentifierNew( "QOUT", TRUE );
         aiHold[ (*ptr_iHold)++ ] = '(' + DONT_REDUCE;
         aiHold[ (*ptr_iHold)++ ] = IDENTIFIER + DONT_REDUCE;
         return _QOUT_LIT;

      case HB_RET_QOUT_LIT :
         yylval.string = hb_compIdentifierNew( sPair, TRUE );
         aiHold[ (*ptr_iHold)++ ] = '\n' + DONT_REDUCE;
         aiHold[ (*ptr_iHold)++ ] = ')' + DONT_REDUCE;
         return LITERAL + DONT_REDUCE ;

      case HB_DO_WHILE_ID :
	 iIdentifier++;
	 DEBUG_INFO( printf( "HB_DO_WHILE_ID, Primary Identifier %s Increased to: %i\n", "WHILE", iIdentifier ) );
         yylval.string = hb_compIdentifierNew( "WHILE", TRUE );
         aiHold[ (*ptr_iHold)++ ] = IDENTIFIER + DONT_REDUCE;
         return DO + DONT_REDUCE;

      case HB_DO_WHILE_WITH :
         aiHold[ (*ptr_iHold)++ ] = WITH + DONT_REDUCE;
         yylval.string = hb_compIdentifierNew( "WHILE", TRUE );
	 iIdentifier++;
	 DEBUG_INFO( printf( "HB_DO_WHILE_WITH, Primary Identifier %s Increased to: %i\n", "WHILE", iIdentifier ) );
         aiHold[ (*ptr_iHold)++ ] = IDENTIFIER + DONT_REDUCE;
         return DO + DONT_REDUCE;

      case HB_DO_CASE_ID :
         yylval.string = hb_compIdentifierNew( "CASE", TRUE );
	 iIdentifier++;
	 DEBUG_INFO( printf( "HB_DO_CASE_ID, Primary Identifier %s Increased to: %i\n", "CASE", iIdentifier ) );
         aiHold[ (*ptr_iHold)++ ] = IDENTIFIER + DONT_REDUCE;
         return DO + DONT_REDUCE;

      case HB_MACRO_ERR :
	 hb_compGenError( hb_comp_szErrors, 'E', HB_COMP_ERR_SYNTAX, "&", NULL );
         return  0;

      case HB_ID_ON_HOLD :
         yylval.string = sIdOnHold;
	 iIdentifier++;
	 DEBUG_INFO( printf( "RELEASED ID_ON_HOLD: %s - Increased to: %i\n", sIdOnHold, iIdentifier ) );
         return IDENTIFIER;

      case HB_INLINE :

	 /* NOTE: hb_compiLineINLINE is being RESET in ppcomp.c - hb_pp_Internal() */

	 if( hb_comp_iLineINLINE )
	 {
            hb_compGenError( hb_comp_szErrors, 'F', HB_COMP_ERR_TOOMANY_INLINE, "on the same line", NULL );
	    iIdentifier++;
	    return IDENTIFIER + DONT_REDUCE;
	 }
	 else
	 {
	    #define INLINE_NORMAL 0
	    #define INLINE_SINGLE_QUOT 1
	    #define INLINE_DOUBLE_QUOT 2
	    #define INLINE_COMMENT 3

	    char sBuffer[ YY_BUF_SIZE ], *pBuffer, sInlineSym[] = "HB_INLINE_0", cMode = INLINE_NORMAL;
	    int iSize, iBraces = 0;
	    extern BOOL hb_pp_bInline;
            PINLINE pInline;

	    hb_comp_iLineINLINE = hb_comp_iLine;
            hb_pp_bInline = TRUE;

	    sInlineSym[10] = hb_comp_cInlineID++;

	    switch( sInlineSym[10] )
	    {
	       case '9' + 1 :
		  sInlineSym[10] = 'A';
		  break;

	       case 'Z' + 1 :
                  hb_compGenError( hb_comp_szErrors, 'F', HB_COMP_ERR_TOOMANY_INLINE, NULL, NULL );
		  break;
	    }

            pInline = hb_compInlineAdd( hb_compIdentifierNew( sInlineSym, TRUE ) );

	  DigestInline :

            YY_INPUT( (char*) sBuffer, iSize, YY_BUF_SIZE );
	    if( iSize == 0 )
	    {
               hb_compGenError( hb_comp_szErrors, 'F', HB_COMP_ERR_INVALID_INLINE, hb_comp_functions.pLast->szName, NULL );
	       hb_pp_bInline = FALSE;
	       return '\n' + DONT_REDUCE;
	    }
	    pBuffer = (char*) sBuffer;

	    while( *pBuffer )
	    {
	       switch( cMode )
	       {
		  case INLINE_NORMAL :
	             if( *pBuffer == '{' )
	             {
	                iBraces++;
	             }
	             else if( *pBuffer == '}' && iBraces > 1 )
	             {
	                iBraces--;
	             }
	             else if( *pBuffer == '}' )
	             {
	                hb_pp_bInline = FALSE;
			break;
	             }
	             else if( *pBuffer == '\'' )
	             {
		        cMode = INLINE_SINGLE_QUOT;
	             }
	             else if( *pBuffer == '"' )
	             {
		        cMode = INLINE_DOUBLE_QUOT;
	             }
	             else if( *pBuffer == '/' && *(pBuffer+1) == '/' )
	             {
		        goto SaveInline;
	             }
	             else if( *pBuffer == '/' && *(pBuffer+1) == '*' )
	             {
		        pBuffer++;
		        cMode = INLINE_COMMENT;
	             }
		     break;

		  case INLINE_SINGLE_QUOT :
		     if( *pBuffer == '\\' )
		     {
		        pBuffer++;
		     }
		     else if( *pBuffer == '\'' )
		     {
			cMode = INLINE_NORMAL;
		     }
		     break;

		  case INLINE_DOUBLE_QUOT :
		     if( *pBuffer == '\\' )
		     {
		        pBuffer++;
		     }
		     else if( *pBuffer == '"' )
		     {
			cMode = INLINE_NORMAL;
		     }
		     break;

		  case INLINE_COMMENT :
		     if( *pBuffer == '*' && *(pBuffer+1) == '/' )
		     {
		        pBuffer++;
			cMode = INLINE_NORMAL;
		     }
		     break;
	       }

               pBuffer++;
	    }

          SaveInline :

	    if( pInline->pCode == NULL )
	    {
               pInline->pCode = (unsigned char *) hb_xgrab( ( iSize = strlen( (char*) sBuffer ) ) + 1 );
               strcpy( (char *) pInline->pCode, (char*) sBuffer );
	    }
	    else
	    {
               pInline->pCode = (unsigned char *) hb_xrealloc( pInline->pCode, pInline->lPCodeSize + ( iSize = strlen( (char*) sBuffer ) ) + 1 );
               strcpy( (char *) (pInline->pCode + pInline->lPCodeSize), (char*) sBuffer );
	    }
	    pInline->lPCodeSize += iSize;

	    if( hb_pp_bInline )
	    {
	       goto DigestInline;
	    }
	    else
	    {
               if( hb_comp_iLanguage != LANG_C && hb_comp_iLanguage != LANG_OBJ_MODULE )
	       {
                  hb_compGenError( hb_comp_szErrors, 'F', HB_COMP_ERR_REQUIRES_C, NULL, NULL );
                  hb_xfree( ( void * ) pInline->pCode );
                  hb_xfree( ( void * ) pInline->szFileName );
                  hb_xfree( ( void * ) pInline );  /* NOTE: szName will be released by hb_compSymbolKill() */
	       }

	       hb_comp_iLinePRG = hb_comp_iLine;
	       hb_comp_iLine = hb_comp_iLineINLINE;

               yylval.string = hb_compIdentifierNew( sInlineSym, TRUE );
	       iIdentifier++;
	       DEBUG_INFO( printf( "INLINE, Primary Identifier %s Increased to: %i\n", "INLINE", iIdentifier ) );
               return IDENTIFIER + DONT_REDUCE;
	    }
	 }

      default:
         printf( "WARNING! No Handler for Custom Action %i\n", x );
   }

   return x;
}

int yy_lex_input( char *buffer, int iBufferSize )
{
   HB_SYMBOL_UNUSED( iBufferSize );

   if( ( hb_comp_iLine % 100 ) == 0 && hb_comp_bQuiet == FALSE )
   {
      printf( "\r%i", hb_comp_iLine );
      fflush( stdout );
   }

   return hb_pp_Internal( hb_comp_bPPO ? hb_comp_yyppo : NULL, buffer );
}

char * hb_comp_SLX_LastBlock( BOOL bReset )
{
   if( bReset && s_sLastBlock )
   {
      /*
      hb_xfree( s_sLastBlock );
      */
      s_sLastBlock = NULL;
   }

   return s_sLastBlock;
}
