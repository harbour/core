/*
 * $Id$
 */

/*
 * Las siguientes partes son derechos adquiridos de sus autores individuales.
 * www - http://www.harbour-project.org
 *
 * Copyright 2001
 *   Documentación en Inglés de: strotype.txt
 *
 * Copyright 2002 Alejandro de Gárate <alex_degarate@hotmail.com>
 *   Documentación en Español de: strotype.txt
 *
 * Vea doc/license.txt por los términos de la licencia.
 *
 */

/*  $DOC$
 *  $FUNCNAME$
 *      Fuertemente tipeado
 *  $CATEGORY$
 *      Document
 *  $ONELINER$
 *      Chequeo de Tipo en Tiempo de Compilación
 *  $DESCRIPTION$
 *      El Strong Type Checking, podría ser también descripto como 
 *      "Chequeo de tipo en Tiempo de Compilación". 
 *      Como Ud. podría saber Clipper genera un error en Tiempo de Ejecución
 *      ("Type Mismatch") cuando nosotros intentamos realizar algunas 
 *      operaciones con el tipo equivocado de variable.
 *      
 *      Ejemplos:
 *
 *      LOCAL Var1 := "A"
 *
 *      ? Var1 * 3       // Error 
 *
 *      @ Var1, 7 SAY 'Hello'   // Error 
 *
 *      ? SubStr( "Hello", Var1 ) // Error 
 *      
 *      Las 3 líneas superiores podrían todas resultar en un error de Tiempo 
 *      de Ejecución, porque Var1 es del tipo CHARACTER, pero las líneas de
 *      arriba la usan como si fuera del tipo NUMERIC.
 *      
 *      Usando un chequeo de Tipo Fuerte, ó Chequeo de Tipo en Tiempo de 
 *      Compilación, el problema de arriba podría haber sido descubierto y
 *      y reportado en tiempo de compilación, antes que esperar que el 
 *      inevitable problema sea descubierto cuando finalmente nosotros 
 *      ejecutemos el programa.
 *      
 *      Los lenguajes fuertemente tipeados permiten al programador "decirle"
 *      al compilador (declarar) cual es el tipo de cada variable, así el
 *      compilador puede advertirle al programador, cuando esa variable
 *      declarada (Strong Typed), es usada en un contexto el cual es 
 *      incompatible con su tipo declarado.
 *      
 *      Por ejemplo si nosotros le "contamos" al compilador que la Var1 de
 *      arriba es del tipo CHARACTER (LOCAL Var1 AS CHARACTER), el compilador
 *      de Harbour, podría en devolución advertirnos que nosotros intentamos
 *      realizar el calculo:
 *
 *      Var1 * 3
 *      
 *      porque el compilador sabe que nosotros no podemos realizar la 
 *      mutiplicación de un CHARACTER. (Nosotros podríamos hacerlo en algún
 *      contexto pero eso esta mas allá del alcance de esta discusión).
 *      Similarmente nosotros podríamos haber sido advertidos cuando 
 *      intentamos usar Var1 como un numero de Fila ( @ Var1 ), ó como el
 *      segundo operando de la función SUBSTR(), SUBSTR( "Hello", Var1)
 *      porque el compilador sabe que esas operaciones requieren un tipo
 *      NUMERIC antes que CHARACTER.
 *      
 *      Lo de arriba puede ahorrarnos un montón de tiempo, señalandonos un
 *      problema del cual no podemos escapar, porque ese código nunca 
 *      funcionará correctamente una vez ejecutado.
 *      Así que antes de esperar al ciclo de testeo, para que tales problemas
 *      sean descubiertos, (y algunas veces aún después de que nosotros 
 *      hemos distribuido nuestras aplicaciones) en su lugar nosotros podemos
 *      saber de esos problemas tan pronto como nosotros tipeamos:
 *      
 *           HARBOUR ProgName -w3
 *      
 *      Harbour también ofrece un modo híbrido, donde puede reportar este
 *      tipo de problemas, aún sin el requerimiento que el programador 
 *      declare el tipo de variables. Esta característica es referida como
 *      Chequeo Adaptativo de Tipo (Adaptive Type Checking).
 *      No es necesario que el programador haga ningún cambio en el código
 *      para tomar ventaja de ésta característica. Todos los 3 errores de
 *      arriba podrían haber sido reportados tan efectivamente como si el
 *      programador hubiera declarado Var1 como de Tipo Fuerte.
 *      
 *      Harbour podría haber sido capaz de reportar tales problemas en 
 *      tiempo de compilación, porque la asignación Var1 := "A" implica que
 *      Var1 es del tipo CHARACTER, hasta que a ésta le sea asignado otro
 *      valor. Así entonces Harbour podría "recordar" que Var1 a "adaptado"
 *      el tipo CHARACTER, y así la multiplicación subsecuente   Var1 * 3
 *      será reportada como un error, tan pronto como Ud. intente compilar
 *      tal código.
 *      
 *      La parte hermosa de este modo híbrido, es que a diferencia de las 
 *      variables Strong Typed, Ud. no tiene que declarar el código, así
 *      que no son necesarios cambios en el código fuente, el Tipo en su
 *      lugar es asumido por implicación (el Tipo del valor asignado).
 *      El otro beneficio es que, es completamente correcto asignar un nuevo
 *      valor de diferente tipo, en cualquier momento, a esa variable no
 *      declarada (variante). Tan pronto como nosotros asignemos un nuevo
 *      tipo, el compilador entonces nos protegerá de usar la variable en un
 *      contexto incompatible, dado que la variable a "adaptado" este Tipo 
 *      tan pronto como nosotros le hemos asignado un valor, el cual implica
 *      un Tipo.
 *      
 *      Mientras el Chequeo Adaptativo de Tipo puede ser completamente 
 *      efectivo en reportar muchos errores comunes, para tener todos los 
 *      beneficios del Chequeo en Tiempo de Compilación es recomendado 
 *      declarar el Tipo de las variables, cuando sea posible.
 *      
 *      Las características del Tipo fuerte (Strong Type), también permiten
 *      la declaración de parámetros esperados (incluyendo opcionales) de las
 *      funciones definidas por el usuario, asi como también el tipo 
 *      retornado.
 *      Similarmente, Ud. puede declarar el tipo de cualquier variable de
 *      Clase, Métodos y Parámetros de Métodos.
 *
 *  $END$
 */
